---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by riley.
--- DateTime: 2020/11/23 2:01 下午
---

local setmetatable = setmetatable
local tonumber = tonumber
local tostring = tostring
local redis = require("resty.redis")

local ok, new_tab = pcall(require, "table.new")
if not ok or type(new_tab) ~= "function" then
    new_tab = function(narr, nrec) return {} end
end

local _M = new_tab(0, 55)
_M._VERSION = '1.0.0'

function _M:new(secret_salt, secret_key, redis_conf)
    local key = secret_key or "Sq1hAQJMRemgKJf7"
    local salt = secret_salt or "ZStXq6jKOlDaP4ID"
    local conf = {
        host = redis_conf and redis_conf["host"] or "127.0.0.1",
        port = redis_conf and redis_conf["port"] or 6379,
        password = redis_conf and redis_conf["password"] or nil
    }

    local instance = { key = key, redis_conf = conf, salt = salt }
    setmetatable(instance, self)
    self.__index = self

    return instance
end

function _M:get_redis_client()
    local redis_client = redis:new()
    local ok, err = redis_client:connect(self.redis_conf['host'], self.redis_conf['port'])
    if not ok then
        return nil, err
    end

    if self.redis_conf['password'] ~= nil then
        ok, err = redis_client:auth(self.redis_conf['password'])
        if not ok then
            return nil, err
        end
    end

    redis_client:select(15)

    return redis_client, nil
end

function _M:encrypt(content)

    local function bxor(n, m)
        if n < m then n, m = m, n end
        local res, shift = 0, 1
        while n ~= 0 do
            res = shift * ((n % 2 + m % 2 == 1) and 1 or 0) + res
            shift = shift * 2
            n, m = math.modf(n / 2), math.modf(m / 2)
        end

        return res
    end

    local function init_secret_key(secret)
        local keyLen, j = secret:len(), 0
        local schedule, keyBytes = new_tab(256, 0), new_tab(keyLen, 0)
        for i = 0, 255 do schedule[i] = i end
        for i = 1, keyLen do keyBytes[i - 1] = secret:byte(i, i) end

        for i = 0, 255 do
            j = (j + schedule[i] + keyBytes[i % keyLen]) % 256
            schedule[i], schedule[j] = schedule[j], schedule[i]
        end

        return schedule
    end

    local function crypt(schedule, text)
        local len = text:len()
        local i, j, k = 0, 0, new_tab(len, 0)
        for n = 1, len do
            i = (i + 1) % 256
            j = (j + schedule[i]) % 256
            schedule[i], schedule[j] = schedule[j], schedule[i]
            k[n] = schedule[(schedule[i] + schedule[j]) % 256]
        end

        local ch, res = nil, new_tab(len, 0)
        for n = 1, len do
            ch = text:byte(n, n)
            res[n] = string.char(bxor(k[n], ch))
        end

        return table.concat(res)
    end

    local schedule = init_secret_key(self.key)

    return crypt(schedule, content)
end

function _M:judge_whether_encrypt(version, need_version)
    if version == nil then return true end

    local v_one_nums, v_two_nums = new_tab(4, 0), new_tab(4, 0)
    version:gsub('%d+', function(w) table.insert(v_one_nums, w) end)
    need_version:gsub('%d+', function(w) table.insert(v_two_nums, w) end)

    local one_num, two_num = #v_one_nums, #v_two_nums
    local num = one_num >= two_num and one_num or two_num
    local one_item_num, two_item_num = 0, 0
    for i = 1, num do
        one_item_num = v_one_nums[i] and tonumber(v_one_nums[i]) or 0
        two_item_num = v_two_nums[i] and tonumber(v_two_nums[i]) or 0
        if one_item_num > two_item_num then
            return true
        elseif one_item_num < two_item_num then
            return false
        end
    end

    return false
end

--function _M:get_sign(timestamp, nonce, body, queries)
function _M:get_sign(timestamp, nonce, body)
    --local function sort_and_join_params(params)
    --    local keys, temps = new_tab(#params, 0), new_tab(#params, 0)
    --    for key, _ in pairs(params) do
    --        table.insert(keys, key)
    --    end
    --
    --    table.sort(keys)
    --    for _, key in pairs(keys) do
    --        local param = params[key]
    --        if type(param) == "string" or type(param) == "number" then
    --            table.insert(temps, key .. "=" .. tostring(param))
    --        end
    --    end
    --
    --    return table.concat(temps, "&")
    --end
    --
    --local queries_type = type(queries)
    --if queries ~= nil and queries_type ~= "table" then
    --    if queries_type == "string" then
    --        local queries_split_map, queries_map = {}
    --        queries:gsub('[^&]+', function (w) table.insert(queries_split_map, w) end)
    --        for _, queries_str in pairs(queries_split_map) do
    --            local queries_str_map = {};
    --            queries_str:gsub('[^=]+', function (w) table.insert(queries_str_map, w) end)
    --            if #queries_str_map == 2 then
    --                queries_map[queries_str_map[1]] = queries_str_map[2]
    --            end
    --        end
    --
    --        queries = queries_map
    --    else
    --        queries = nil
    --    end
    --end

    local params_str = timestamp .. nonce .. self.salt
    if body ~= nil then params_str = params_str .. body end

    --if queries ~= nil and _G.next(queries) ~= nil then
    --    params_str = sort_and_join_params(queries) .. params_str
    --end

    local sign = io.popen("echo -n '" .. params_str .. "'|md5sum")
                   :read("*all"):sub(1, -5)

    return self:sign_is_valid(sign) and sign or nil
end

function _M:sign_is_valid(sign)
    local redis_client, err = self:get_redis_client()

    if err == nil then
        local sign_is_used, err = redis_client:exists(sign)

        if tonumber(sign_is_used) == 0 and err == nil then
            local ok, _ = redis_client:set(sign, io.popen("date +%s"):read("*all"):sub(1, 10))
            if ok then redis_client:expire(sign, "3600") end

            return true;
        end

        if err == nil then
            redis_client:set_keepalive(10000, 100)
        end
    end

    return false
end

return _M:new("SALT", "KEY",
    { host = "REDIS host", port = 6379, password = "REDIS密码" })
